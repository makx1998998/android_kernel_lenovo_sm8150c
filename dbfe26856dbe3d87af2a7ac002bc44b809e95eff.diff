diff --git a/drivers/gpu/msm/kgsl_gmu.c b/drivers/gpu/msm/kgsl_gmu.c
index 7b9f15f79a7d..7a8eab90c94e 100644
--- a/drivers/gpu/msm/kgsl_gmu.c
+++ b/drivers/gpu/msm/kgsl_gmu.c
@@ -1610,7 +1610,7 @@ static int gmu_start(struct kgsl_device *device)
 
 		/* Vote for 300MHz DDR for GMU to init */
 		ret = msm_bus_scale_client_update_request(gmu->pcl,
-				pwr->pwrlevels[pwr->default_pwrlevel].bus_freq);
+				pwr->pwrlevels[pwr->num_pwrlevels - 1].bus_freq);
 		if (ret)
 			dev_err(&gmu->pdev->dev,
 				"Failed to allocate gmu b/w: %d\n", ret);
diff --git a/drivers/gpu/msm/kgsl_pwrctrl.c b/drivers/gpu/msm/kgsl_pwrctrl.c
index 95190163a4ca..361add341014 100644
--- a/drivers/gpu/msm/kgsl_pwrctrl.c
+++ b/drivers/gpu/msm/kgsl_pwrctrl.c
@@ -168,8 +168,7 @@ static void _ab_buslevel_update(struct kgsl_pwrctrl *pwr,
  * constraint if one exists.
  */
 static unsigned int _adjust_pwrlevel(struct kgsl_pwrctrl *pwr, int level,
-					struct kgsl_pwr_constraint *pwrc,
-					int popp)
+					struct kgsl_pwr_constraint *pwrc)
 {
 	unsigned int max_pwrlevel = max_t(unsigned int, pwr->thermal_pwrlevel,
 					pwr->max_pwrlevel);
@@ -191,9 +190,6 @@ static unsigned int _adjust_pwrlevel(struct kgsl_pwrctrl *pwr, int level,
 	break;
 	}
 
-	if (popp && (max_pwrlevel < pwr->active_pwrlevel))
-		max_pwrlevel = pwr->active_pwrlevel;
-
 	if (level < max_pwrlevel)
 		return max_pwrlevel;
 	if (level > min_pwrlevel)
@@ -394,8 +390,7 @@ unsigned int kgsl_pwrctrl_adjust_pwrlevel(struct kgsl_device *device,
 	 * Adjust the power level if required by thermal, max/min,
 	 * constraints, etc
 	 */
-	return _adjust_pwrlevel(pwr, new_level, &pwr->constraint,
-					device->pwrscale.popp_level);
+	return _adjust_pwrlevel(pwr, new_level, &pwr->constraint);
 }
 
 /**
@@ -556,7 +551,7 @@ void kgsl_pwrctrl_set_constraint(struct kgsl_device *device,
 	if (device == NULL || pwrc == NULL)
 		return;
 	constraint = _adjust_pwrlevel(&device->pwrctrl,
-				device->pwrctrl.active_pwrlevel, pwrc, 0);
+				device->pwrctrl.active_pwrlevel, pwrc);
 	pwrc_old = &device->pwrctrl.constraint;
 
 	/*
@@ -1243,89 +1238,6 @@ static ssize_t kgsl_pwrctrl_bus_split_store(struct device *dev,
 	return count;
 }
 
-static ssize_t kgsl_pwrctrl_default_pwrlevel_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	struct kgsl_device *device = kgsl_device_from_dev(dev);
-
-	if (device == NULL)
-		return 0;
-	return snprintf(buf, PAGE_SIZE, "%d\n",
-		device->pwrctrl.default_pwrlevel);
-}
-
-static ssize_t kgsl_pwrctrl_default_pwrlevel_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct kgsl_device *device = kgsl_device_from_dev(dev);
-	struct kgsl_pwrctrl *pwr;
-	struct kgsl_pwrscale *pwrscale;
-	int ret;
-	unsigned int level = 0;
-
-	if (device == NULL)
-		return 0;
-
-	pwr = &device->pwrctrl;
-	pwrscale = &device->pwrscale;
-
-	ret = kgsl_sysfs_store(buf, &level);
-	if (ret)
-		return ret;
-
-	if (level > pwr->num_pwrlevels - 2)
-		goto done;
-
-	mutex_lock(&device->mutex);
-	pwr->default_pwrlevel = level;
-	pwrscale->gpu_profile.profile.initial_freq
-			= pwr->pwrlevels[level].gpu_freq;
-
-	mutex_unlock(&device->mutex);
-done:
-	return count;
-}
-
-
-static ssize_t kgsl_popp_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	unsigned int val = 0;
-	struct kgsl_device *device = kgsl_device_from_dev(dev);
-	int ret;
-
-	if (device == NULL)
-		return 0;
-
-	ret = kgsl_sysfs_store(buf, &val);
-	if (ret)
-		return ret;
-
-	mutex_lock(&device->mutex);
-	if (val)
-		set_bit(POPP_ON, &device->pwrscale.popp_state);
-	else
-		clear_bit(POPP_ON, &device->pwrscale.popp_state);
-	mutex_unlock(&device->mutex);
-
-	return count;
-}
-
-static ssize_t kgsl_popp_show(struct device *dev,
-					   struct device_attribute *attr,
-					   char *buf)
-{
-	struct kgsl_device *device = kgsl_device_from_dev(dev);
-
-	if (device == NULL)
-		return 0;
-	return snprintf(buf, PAGE_SIZE, "%d\n",
-		test_bit(POPP_ON, &device->pwrscale.popp_state));
-}
-
 static ssize_t kgsl_pwrctrl_gpu_model_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -1602,10 +1514,6 @@ static DEVICE_ATTR(force_rail_on, 0644,
 static DEVICE_ATTR(bus_split, 0644,
 	kgsl_pwrctrl_bus_split_show,
 	kgsl_pwrctrl_bus_split_store);
-static DEVICE_ATTR(default_pwrlevel, 0644,
-	kgsl_pwrctrl_default_pwrlevel_show,
-	kgsl_pwrctrl_default_pwrlevel_store);
-static DEVICE_ATTR(popp, 0644, kgsl_popp_show, kgsl_popp_store);
 static DEVICE_ATTR(force_no_nap, 0644,
 	kgsl_pwrctrl_force_no_nap_show,
 	kgsl_pwrctrl_force_no_nap_store);
@@ -1641,8 +1549,6 @@ static const struct device_attribute *pwrctrl_attr_list[] = {
 	&dev_attr_force_rail_on,
 	&dev_attr_force_no_nap,
 	&dev_attr_bus_split,
-	&dev_attr_default_pwrlevel,
-	&dev_attr_popp,
 	&dev_attr_gpu_model,
 	&dev_attr_gpu_busy_percentage,
 	&dev_attr_min_clock_mhz,
@@ -2650,10 +2556,8 @@ static int kgsl_pwrctrl_enable(struct kgsl_device *device)
 	if (pwr->wakeup_maxpwrlevel) {
 		level = pwr->max_pwrlevel;
 		pwr->wakeup_maxpwrlevel = 0;
-	} else if (kgsl_popp_check(device)) {
-		level = pwr->active_pwrlevel;
 	} else {
-		level = pwr->default_pwrlevel;
+		level = pwr->num_pwrlevels - 1;
 	}
 
 	kgsl_pwrctrl_pwrlevel_change(device, level);
diff --git a/drivers/gpu/msm/kgsl_pwrctrl.h b/drivers/gpu/msm/kgsl_pwrctrl.h
index 73da4851492f..f5e31f898191 100644
--- a/drivers/gpu/msm/kgsl_pwrctrl.h
+++ b/drivers/gpu/msm/kgsl_pwrctrl.h
@@ -131,7 +131,6 @@ struct kgsl_regulator {
  * @previous_pwrlevel - The power level before transition
  * @thermal_pwrlevel - maximum powerlevel constraint from thermal
  * @thermal_pwrlevel_floor - minimum powerlevel constraint from thermal
- * @default_pwrlevel - device wake up power level
  * @max_pwrlevel - maximum allowable powerlevel per the user
  * @min_pwrlevel - minimum allowable powerlevel per the user
  * @num_pwrlevels - number of available power levels
@@ -189,7 +188,6 @@ struct kgsl_pwrctrl {
 	unsigned int previous_pwrlevel;
 	unsigned int thermal_pwrlevel;
 	unsigned int thermal_pwrlevel_floor;
-	unsigned int default_pwrlevel;
 	unsigned int wakeup_maxpwrlevel;
 	unsigned int max_pwrlevel;
 	unsigned int min_pwrlevel;
diff --git a/drivers/gpu/msm/kgsl_pwrscale.c b/drivers/gpu/msm/kgsl_pwrscale.c
index 244118f31d19..b06be9668504 100644
--- a/drivers/gpu/msm/kgsl_pwrscale.c
+++ b/drivers/gpu/msm/kgsl_pwrscale.c
@@ -22,24 +22,6 @@
 #include "kgsl_device.h"
 #include "kgsl_trace.h"
 
-/*
- * "SLEEP" is generic counting both NAP & SLUMBER
- * PERIODS generally won't exceed 9 for the relavent 150msec
- * window, but can be significantly smaller and still POPP
- * pushable in cases where SLUMBER is involved.  Hence the
- * additional reliance on PERCENT to make sure a reasonable
- * amount of down-time actually exists.
- */
-#define MIN_SLEEP_PERIODS	3
-#define MIN_SLEEP_PERCENT	5
-
-static struct kgsl_popp popp_param[POPP_MAX] = {
-	{0, 0},
-	{-5, 20},
-	{-5, 0},
-	{0, 0},
-};
-
 /**
  * struct kgsl_midframe_info - midframe power stats sampling info
  * @timer - midframe sampling timer
@@ -71,15 +53,10 @@ static struct devfreq_dev_status last_status = { .private_data = &last_xstats };
  */
 void kgsl_pwrscale_sleep(struct kgsl_device *device)
 {
-	struct kgsl_pwrscale *psc = &device->pwrscale;
-
 	if (!device->pwrscale.enabled)
 		return;
 	device->pwrscale.on_time = 0;
 
-	psc->popp_level = 0;
-	clear_bit(POPP_PUSH, &device->pwrscale.popp_state);
-
 	/* to call devfreq_suspend_device() from a kernel thread */
 	queue_work(device->pwrscale.devfreq_wq,
 		&device->pwrscale.devfreq_suspend_ws);
@@ -153,18 +130,6 @@ void kgsl_pwrscale_update_stats(struct kgsl_device *device)
 		struct kgsl_power_stats stats;
 
 		device->ftbl->power_stats(device, &stats);
-		if (psc->popp_level) {
-			u64 x = stats.busy_time;
-			u64 y = stats.ram_time;
-
-			do_div(x, 100);
-			do_div(y, 100);
-			x *= popp_param[psc->popp_level].gpu_x;
-			y *= popp_param[psc->popp_level].ddr_y;
-			trace_kgsl_popp_mod(device, x, y);
-			stats.busy_time += x;
-			stats.ram_time += y;
-		}
 		device->pwrscale.accum_stats.busy_time += stats.busy_time;
 		device->pwrscale.accum_stats.ram_time += stats.ram_time;
 		device->pwrscale.accum_stats.ram_wait += stats.ram_wait;
@@ -298,7 +263,7 @@ void kgsl_pwrscale_enable(struct kgsl_device *device)
 		 * run at default level;
 		 */
 		kgsl_pwrctrl_pwrlevel_change(device,
-					device->pwrctrl.default_pwrlevel);
+					device->pwrctrl.num_pwrlevels - 1);
 		device->pwrscale.enabled = false;
 	}
 }
@@ -319,194 +284,6 @@ static int _thermal_adjust(struct kgsl_pwrctrl *pwr, int level)
 	return level;
 }
 
-/*
- * Use various metrics including level stability, NAP intervals, and
- * overall GPU freq / DDR freq combination to decide if POPP should
- * be activated.
- */
-static bool popp_stable(struct kgsl_device *device)
-{
-	s64 t;
-	s64 nap_time = 0;
-	s64 go_time = 0;
-	int i, index;
-	int nap = 0;
-	s64 percent_nap = 0;
-	struct kgsl_pwr_event *e;
-	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
-	struct kgsl_pwrscale *psc = &device->pwrscale;
-
-	if (!test_bit(POPP_ON, &psc->popp_state))
-		return false;
-
-	/* If already pushed or running naturally at min don't push further */
-	if (test_bit(POPP_PUSH, &psc->popp_state))
-		return false;
-	if (!psc->popp_level &&
-			(pwr->active_pwrlevel == pwr->min_pwrlevel))
-		return false;
-	if (psc->history[KGSL_PWREVENT_STATE].events == NULL)
-		return false;
-
-	t = ktime_to_ms(ktime_get());
-	/* Check for recent NAP statistics: NAPping regularly and well? */
-	if (pwr->active_pwrlevel == 0) {
-		index = psc->history[KGSL_PWREVENT_STATE].index;
-		i = index > 0 ? (index - 1) :
-			(psc->history[KGSL_PWREVENT_STATE].size - 1);
-		while (i != index) {
-			e = &psc->history[KGSL_PWREVENT_STATE].events[i];
-			if (e->data == KGSL_STATE_NAP ||
-				e->data == KGSL_STATE_SLUMBER) {
-				if (ktime_to_ms(e->start) + STABLE_TIME > t) {
-					nap++;
-					nap_time += e->duration;
-				}
-			} else if (e->data == KGSL_STATE_ACTIVE) {
-				if (ktime_to_ms(e->start) + STABLE_TIME > t)
-					go_time += e->duration;
-			}
-			if (i == 0)
-				i = psc->history[KGSL_PWREVENT_STATE].size - 1;
-			else
-				i--;
-		}
-		if (nap_time && go_time) {
-			percent_nap = 100 * nap_time;
-			div64_s64(percent_nap, nap_time + go_time);
-		}
-		trace_kgsl_popp_nap(device, (int)nap_time / 1000, nap,
-				percent_nap);
-		/* If running high at turbo, don't push */
-		if (nap < MIN_SLEEP_PERIODS || percent_nap < MIN_SLEEP_PERCENT)
-			return false;
-	}
-
-	/* Finally check that there hasn't been a recent change */
-	if ((device->pwrscale.freq_change_time + STABLE_TIME) < t) {
-		device->pwrscale.freq_change_time = t;
-		return true;
-	}
-	return false;
-}
-
-bool kgsl_popp_check(struct kgsl_device *device)
-{
-	int i;
-	unsigned int index;
-	struct kgsl_pwrscale *psc = &device->pwrscale;
-	struct kgsl_pwr_event *e;
-
-	if (!test_bit(POPP_ON, &psc->popp_state))
-		return false;
-	if (!test_bit(POPP_PUSH, &psc->popp_state))
-		return false;
-	if (psc->history[KGSL_PWREVENT_STATE].events == NULL) {
-		clear_bit(POPP_PUSH, &psc->popp_state);
-		return false;
-	}
-	index = psc->history[KGSL_PWREVENT_STATE].index;
-
-	e = &psc->history[KGSL_PWREVENT_STATE].events[index];
-	if (e->data == KGSL_STATE_SLUMBER)
-		e->duration = ktime_us_delta(ktime_get(), e->start);
-
-	/* If there's been a long SLUMBER in recent history, clear the _PUSH */
-	for (i = 0; i < psc->history[KGSL_PWREVENT_STATE].size; i++) {
-		e = &psc->history[KGSL_PWREVENT_STATE].events[i];
-		if ((e->data == KGSL_STATE_SLUMBER) &&
-			 (e->duration > POPP_RESET_TIME)) {
-			clear_bit(POPP_PUSH, &psc->popp_state);
-			return false;
-		}
-	}
-	return true;
-}
-
-/*
- * The GPU has been running at the current frequency for a while.  Attempt
- * to lower the frequency for boarderline cases.
- */
-static void popp_trans1(struct kgsl_device *device)
-{
-	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
-	struct kgsl_pwrlevel *pl = &pwr->pwrlevels[pwr->active_pwrlevel];
-	struct kgsl_pwrscale *psc = &device->pwrscale;
-	int old_level = psc->popp_level;
-
-	switch (old_level) {
-	case 0:
-		psc->popp_level = 2;
-		/* If the current level has a high default bus don't push it */
-		if (pl->bus_freq == pl->bus_max)
-			pwr->bus_mod = 1;
-		kgsl_pwrctrl_pwrlevel_change(device, pwr->active_pwrlevel + 1);
-		break;
-	case 1:
-	case 2:
-		psc->popp_level++;
-		break;
-	case 3:
-		set_bit(POPP_PUSH, &psc->popp_state);
-		psc->popp_level = 0;
-		break;
-	case POPP_MAX:
-	default:
-		psc->popp_level = 0;
-		break;
-	}
-
-	trace_kgsl_popp_level(device, old_level, psc->popp_level);
-}
-
-/*
- * The GPU DCVS algorithm recommends a level change.  Apply any
- * POPP restrictions and update the level accordingly
- */
-static int popp_trans2(struct kgsl_device *device, int level)
-{
-	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
-	struct kgsl_pwrscale *psc = &device->pwrscale;
-	int old_level = psc->popp_level;
-
-	if (!test_bit(POPP_ON, &psc->popp_state))
-		return level;
-
-	clear_bit(POPP_PUSH, &psc->popp_state);
-	/* If the governor recommends going down, do it! */
-	if (pwr->active_pwrlevel < level) {
-		psc->popp_level = 0;
-		trace_kgsl_popp_level(device, old_level, psc->popp_level);
-		return level;
-	}
-
-	switch (psc->popp_level) {
-	case 0:
-		/* If the feature isn't engaged, go up immediately */
-		break;
-	case 1:
-		/* Turn off mitigation, and go up a level */
-		psc->popp_level = 0;
-		break;
-	case 2:
-	case 3:
-		/* Try a more aggressive mitigation */
-		psc->popp_level--;
-		level++;
-		/* Update the stable timestamp */
-		device->pwrscale.freq_change_time = ktime_to_ms(ktime_get());
-		break;
-	case POPP_MAX:
-	default:
-		psc->popp_level = 0;
-		break;
-	}
-
-	trace_kgsl_popp_level(device, old_level, psc->popp_level);
-
-	return level;
-}
-
 #ifdef DEVFREQ_FLAG_WAKEUP_MAXFREQ
 static inline bool _check_maxfreq(u32 flags)
 {
@@ -573,13 +350,11 @@ int kgsl_devfreq_target(struct device *dev, unsigned long *freq, u32 flags)
 				if (pwr->thermal_cycle == CYCLE_ACTIVE)
 					level = _thermal_adjust(pwr, i);
 				else
-					level = popp_trans2(device, i);
+					level = i;
 				break;
 			}
 		if (level != pwr->active_pwrlevel)
 			kgsl_pwrctrl_pwrlevel_change(device, level);
-	} else if (popp_stable(device)) {
-		popp_trans1(device);
 	}
 
 	*freq = kgsl_pwrctrl_active_freq(pwr);
@@ -958,7 +733,7 @@ int kgsl_pwrscale_init(struct device *dev, const char *governor)
 	srcu_init_notifier_head(&pwrscale->nh);
 
 	profile->initial_freq =
-		pwr->pwrlevels[pwr->default_pwrlevel].gpu_freq;
+		pwr->pwrlevels[pwr->num_pwrlevels - 1].gpu_freq;
 	/* Let's start with 10 ms and tune in later */
 	profile->polling_ms = 10;
 
diff --git a/drivers/gpu/msm/kgsl_pwrscale.h b/drivers/gpu/msm/kgsl_pwrscale.h
index 9e28b6594b8d..6900d197dc7f 100644
--- a/drivers/gpu/msm/kgsl_pwrscale.h
+++ b/drivers/gpu/msm/kgsl_pwrscale.h
@@ -25,8 +25,7 @@
 #define KGSL_PWREVENT_STATE	0
 #define KGSL_PWREVENT_GPU_FREQ	1
 #define KGSL_PWREVENT_BUS_FREQ	2
-#define KGSL_PWREVENT_POPP	3
-#define KGSL_PWREVENT_MAX	4
+#define KGSL_PWREVENT_MAX	3
 
 /**
  * Amount of time running at a level to be considered
@@ -34,21 +33,6 @@
  */
 #define STABLE_TIME	150
 
-/* Amount of idle time needed to re-set stability in usec */
-#define POPP_RESET_TIME	1000000
-
-/* Number of POPP levels */
-#define POPP_MAX	4
-
-/* POPP state bits */
-#define POPP_ON		BIT(0)
-#define POPP_PUSH	BIT(1)
-
-struct kgsl_popp {
-	int gpu_x;
-	int ddr_y;
-};
-
 struct kgsl_power_stats {
 	u64 busy_time;
 	u64 ram_time;
@@ -79,7 +63,7 @@ struct kgsl_pwr_history {
  * @enabled - Whether or not power scaling is enabled
  * @time - Last submitted sample timestamp
  * @on_time - Timestamp when gpu busy begins
- * @freq_change_time - Timestamp of last freq change or popp update
+ * @freq_change_time - Timestamp of last freq change
  * @nh - Notifier for the partner devfreq bus device
  * @devfreq_wq - Main devfreq workqueue
  * @devfreq_suspend_ws - Pass device suspension to devfreq
@@ -88,8 +72,6 @@ struct kgsl_pwr_history {
  * @next_governor_call - Timestamp after which the governor may be notified of
  * a new sample
  * @history - History of power events with timestamps and durations
- * @popp_level - Current level of POPP mitigation
- * @popp_state - Control state for POPP, on/off, recently pushed, etc
  * @cooling_dev - Thermal cooling device handle
  * @ctxt_aware_enable - Whether or not ctxt aware DCVS feature is enabled
  * @ctxt_aware_busy_penalty - The time in microseconds required to trigger
@@ -115,8 +97,6 @@ struct kgsl_pwrscale {
 	struct work_struct devfreq_notify_ws;
 	ktime_t next_governor_call;
 	struct kgsl_pwr_history history[KGSL_PWREVENT_MAX];
-	int popp_level;
-	unsigned long popp_state;
 	struct thermal_cooling_device *cooling_dev;
 	bool ctxt_aware_enable;
 	unsigned int ctxt_aware_target_pwrlevel;
@@ -148,9 +128,6 @@ int kgsl_busmon_get_dev_status(struct device *dev,
 			struct devfreq_dev_status *stat);
 int kgsl_busmon_get_cur_freq(struct device *dev, unsigned long *freq);
 
-bool kgsl_popp_check(struct kgsl_device *device);
-
-
 #define KGSL_PWRSCALE_INIT(_priv_data) { \
 	.enabled = true, \
 	.gpu_profile = { \
@@ -170,6 +147,5 @@ bool kgsl_popp_check(struct kgsl_device *device);
 	.history[KGSL_PWREVENT_STATE].size = 20, \
 	.history[KGSL_PWREVENT_GPU_FREQ].size = 3, \
 	.history[KGSL_PWREVENT_BUS_FREQ].size = 5, \
-	.history[KGSL_PWREVENT_POPP].size = 5, \
 	}
 #endif
diff --git a/drivers/gpu/msm/kgsl_trace.h b/drivers/gpu/msm/kgsl_trace.h
index d301949b6765..e7a6516a3940 100644
--- a/drivers/gpu/msm/kgsl_trace.h
+++ b/drivers/gpu/msm/kgsl_trace.h
@@ -873,78 +873,6 @@ TRACE_EVENT(kgsl_regwrite,
 	)
 );
 
-TRACE_EVENT(kgsl_popp_level,
-
-	TP_PROTO(struct kgsl_device *device, int level1, int level2),
-
-	TP_ARGS(device, level1, level2),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(int, level1)
-		__field(int, level2)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->level1 = level1;
-		__entry->level2 = level2;
-	),
-
-	TP_printk(
-		"d_name=%s old level=%d new level=%d",
-		__get_str(device_name), __entry->level1, __entry->level2)
-);
-
-TRACE_EVENT(kgsl_popp_mod,
-
-	TP_PROTO(struct kgsl_device *device, int x, int y),
-
-	TP_ARGS(device, x, y),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(int, x)
-		__field(int, y)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->x = x;
-		__entry->y = y;
-	),
-
-	TP_printk(
-		"d_name=%s GPU busy mod=%d bus busy mod=%d",
-		__get_str(device_name), __entry->x, __entry->y)
-);
-
-TRACE_EVENT(kgsl_popp_nap,
-
-	TP_PROTO(struct kgsl_device *device, int t, int nap, int percent),
-
-	TP_ARGS(device, t, nap, percent),
-
-	TP_STRUCT__entry(
-		__string(device_name, device->name)
-		__field(int, t)
-		__field(int, nap)
-		__field(int, percent)
-	),
-
-	TP_fast_assign(
-		__assign_str(device_name, device->name);
-		__entry->t = t;
-		__entry->nap = nap;
-		__entry->percent = percent;
-	),
-
-	TP_printk(
-		"d_name=%s nap time=%d number of naps=%d percentage=%d",
-		__get_str(device_name), __entry->t, __entry->nap,
-			__entry->percent)
-);
-
 TRACE_EVENT(kgsl_register_event,
 		TP_PROTO(unsigned int id, unsigned int timestamp, void *func),
 		TP_ARGS(id, timestamp, func),
