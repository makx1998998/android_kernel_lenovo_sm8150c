diff --git a/include/trace/events/sched.h b/include/trace/events/sched.h
index 270a3e1b3e1a..9dd3db0a6c49 100755
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@ -1499,10 +1499,10 @@ TRACE_EVENT(sched_task_util,
 	TP_PROTO(struct task_struct *p, int next_cpu, int backup_cpu,
 		int target_cpu, bool sync, bool need_idle, int fastpath,
 		bool placement_boost, int rtg_cpu, u64 start_t,
-		bool stune_boosted),
+		bool stune_boosted, bool sync_boost),
 
 	TP_ARGS(p, next_cpu, backup_cpu, target_cpu, sync, need_idle, fastpath,
-		placement_boost, rtg_cpu, start_t, stune_boosted),
+		placement_boost, rtg_cpu, start_t, stune_boosted, sync_boost),
 
 	TP_STRUCT__entry(
 		__field(int, pid			)
@@ -1519,6 +1519,7 @@ TRACE_EVENT(sched_task_util,
 		__field(int, rtg_cpu			)
 		__field(u64, latency			)
 		__field(bool, stune_boosted		)
+		__field(bool, sync_boost		)
 	),
 
 	TP_fast_assign(
@@ -1536,14 +1537,15 @@ TRACE_EVENT(sched_task_util,
 		__entry->rtg_cpu		= rtg_cpu;
 		__entry->latency		= (sched_clock() - start_t);
 		__entry->stune_boosted		= stune_boosted;
+		__entry->sync_boost		= sync_boost;
 	),
 
-	TP_printk("pid=%d comm=%s util=%lu prev_cpu=%d next_cpu=%d backup_cpu=%d target_cpu=%d sync=%d need_idle=%d fastpath=%d placement_boost=%d rtg_cpu=%d latency=%llu stune_boosted=%d",
+	TP_printk("pid=%d comm=%s util=%lu prev_cpu=%d next_cpu=%d backup_cpu=%d target_cpu=%d sync=%d need_idle=%d fastpath=%d placement_boost=%d rtg_cpu=%d latency=%llu stune_boosted=%d sync_boost=%d",
 		__entry->pid, __entry->comm, __entry->util, __entry->prev_cpu,
 		__entry->next_cpu, __entry->backup_cpu, __entry->target_cpu,
 		__entry->sync, __entry->need_idle, __entry->fastpath,
 		__entry->placement_boost, __entry->rtg_cpu, __entry->latency,
-		__entry->stune_boosted)
+		__entry->stune_boosted, __entry->sync_boost)
 )
 #endif
 /*
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index bec6c77d0601..ad9ef602b4ed 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -7833,6 +7833,7 @@ static int find_energy_efficient_cpu(struct sched_domain *sd,
 				     int sync)
 {
 	int use_fbt = sched_feat(FIND_BEST_TARGET);
+	int use_sync_boost = sched_feat(SYNC_BOOST);
 	int cpu_iter, eas_cpu_idx = EAS_CPU_NXT;
 	int delta = 0;
 	int target_cpu = -1;
@@ -7846,6 +7847,7 @@ static int find_energy_efficient_cpu(struct sched_domain *sd,
 
 	int boosted = (schedtune_task_boost(p) > 0 || per_task_boost(p) > 0);
 	bool about_to_idle = (cpu_rq(cpu)->nr_running < 2);
+	bool sync_boost = false;
 
 	fbt_env.fastpath = 0;
 
@@ -7861,6 +7863,13 @@ static int find_energy_efficient_cpu(struct sched_domain *sd,
 		fbt_env.fastpath = SYNC_WAKEUP;
 		goto out;
 	}
+
+	if (use_sync_boost) {
+		sync_boost = sync && cpu >= start_cpu(p, true, 0);
+	} else {
+		sync_boost = false;
+	}
+
 	/* prepopulate energy diff environment */
 	eenv = get_eenv(p, prev_cpu);
 	if (eenv->max_cpu_count < 2)
@@ -7917,7 +7926,7 @@ static int find_energy_efficient_cpu(struct sched_domain *sd,
 
 		/* Find a cpu with sufficient capacity */
 		target_cpu = find_best_target(p, &eenv->cpu[EAS_CPU_BKP].cpu_id,
-					      boosted, prefer_idle, &fbt_env);
+					      boosted || sync_boost, prefer_idle, &fbt_env);
 		if (target_cpu < 0)
 			goto out;
 
@@ -7967,7 +7976,7 @@ static int find_energy_efficient_cpu(struct sched_domain *sd,
 	trace_sched_task_util(p, next_cpu, backup_cpu, target_cpu, sync,
 			need_idle, fbt_env.fastpath, placement_boost,
 			rtg_target ? cpumask_first(rtg_target) : -1, start_t,
-			boosted);
+			boosted, sync_boost);
 	return target_cpu;
 }
 
diff --git a/kernel/sched/features.h b/kernel/sched/features.h
index 4449a5ea5ab2..ba9b84a9c217 100644
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -124,3 +124,12 @@ SCHED_FEAT(ENERGY_AWARE, false)
 SCHED_FEAT(EAS_PREFER_IDLE, true)
 SCHED_FEAT(FIND_BEST_TARGET, true)
 SCHED_FEAT(FBT_STRICT_ORDER, false)
+
+/*
+* If the sync flag is set but ignored, prefer to
+* select cpu in the same cluster as current. So
+* if current is a big cpu and sync is set, indicate
+* that the selection algorithm for a boosted task
+* should be used.
+*/
+SCHED_FEAT(SYNC_BOOST, true)
